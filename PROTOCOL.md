# مستندات پروتکل رخشان

این سند پروتکل‌های کلیدی افزایش حریم خصوصی را که در سرور رخشان پیاده‌سازی شده‌اند، تشریح می‌کند. این پروتکل‌ها برای محافظت از فراداده (metadata) کاربران و دشوار کردن تحلیل ترافیک طراحی شده‌اند.

## ۱. فرستنده پنهان (Sealed Sender)

برای محافظت از هویت فرستنده پیام، سرور از مدل "فرستنده پنهان" استفاده می‌کند.

- **نحوه کار:** هنگامی که کلاینت پیامی ارسال می‌کند، درخواست (`POST /api/messages`) شامل `conversationId`، `recipientId` و یک `ciphertextPayload` است. نکته مهم این است که این درخواست **فاقد `senderId`** می‌باشد.
- **نقش سرور:** سرور تأیید می‌کند که کاربر احراز هویت شده (از طریق توکن JWT) عضوی از `conversationId` است، اما **هرگز شناسه فرستنده را در رکورد پیام در پایگاه داده ذخیره نمی‌کند.**
- **نتیجه:** اگر یک مهاجم به پایگاه داده پیام‌ها دسترسی پیدا کند، نمی‌تواند تشخیص دهد چه کسی کدام پیام را ارسال کرده است. مدل `Message` در پایگاه داده فقط یک پیام را به یک گفتگو و یک گیرنده مرتبط می‌کند. هویت فرستنده موقتی است و فقط برای شرکت‌کنندگان آن گفتگو مشخص است.

## ۲. پنهان‌سازی ترافیک (Traffic Obfuscation)

سرور از مکانیزم‌های مختلفی برای پنهان‌سازی الگوهای ترافیک شبکه استفاده می‌کند تا تحلیل رفتار کاربر بر اساس حجم و زمان‌بندی ترافیک را برای ناظران دشوارتر سازد.

### پنهان‌سازی در سطح HTTP

- **Padding تصادفی (پاسخ):** به هر پاسخ HTTP که از سرور به کلاینت ارسال می‌شود، با احتمال تصادفی، یک مقدار Padding با حجم تصادفی (بین ۱۰ تا ۵۰۰ بایت) در هدر `X-Padding` اضافه می‌شود.
- **تأخیر تصادفی (پاسخ):** هر پاسخ HTTP سرور قبل از ارسال، به مدت زمانی تصادفی (بین ۵۰ تا ۳۰۰ میلی‌ثانیه) دچار تأخیر می‌شود.

این اقدامات به جداسازی حجم و زمان‌بندی اقدامات واقعی کاربر از ترافیک HTTP قابل مشاهده شبکه کمک می‌کنند.

### ترافیک پوششی دوطرفه در سطح WebSocket

برای مقابله با تحلیل الگوهای ترافیک در زمان واقعی (real-time)، سرور یک جریان ترافیک پوششی متغیر و دوطرفه را از طریق WebSocket پیاده‌سازی می‌کند. این کار باعث می‌شود که تشخیص اینکه چه زمانی پیام‌های واقعی ارسال یا دریافت می‌شوند، بسیار دشوارتر شود.

- **ترافیک پوششی سرور به کلاینت (`padding_traffic`):**
  - **نحوه کار:** سرور در **بازه های زمانی تصادفی (بین ۰.۵ تا ۲ ثانیه)** یک بسته داده با **حجم تصادفی (بین ۵۱۲ تا ۲۰۴۸ بایت)** و محتوای رمزنگاری‌شده تصادفی به *تمام کلاینت‌های متصل و احراز هویت شده* ارسال می‌کند. این ترافیک از طریق رویداد WebSocket به نام `padding_traffic` ارسال می‌شود.
  - **هدف:** ایجاد یک جریان ترافیک **نامنظم و غیرقابل پیش‌بینی** از سمت سرور به کلاینت، که ترافیک پیام‌های واقعی را پنهان می‌کند و از شناسایی الگوهای ثابت جلوگیری می‌کند.

- **ترافیک پوششی کلاینت به سرور (`client_padding`):**
  - **نحوه کار:** برای ایجاد تقارن در ترافیک، به کلاینت‌ها **اکیداً توصیه می‌شود** که بسته‌های پوششی خود را به سرور ارسال کنند. کلاینت‌ها باید به صورت دوره‌ای (مثلاً در فواصل زمانی تصادفی) بسته‌هایی با حجم تصادفی به رویداد WebSocket سرور به نام `client_padding` ارسال کنند.
  - **نقش سرور:** سرور این بسته‌ها را دریافت کرده و نادیده می‌گیرد. هدف اصلی این است که یک جریان ترافیک از سمت کلاینت به سرور ایجاد شود تا از یک‌طرفه بودن ترافیک جلوگیری شود.
  - **نتیجه:** با ترکیب هر دو جریان ترافیک پوششی، یک ناظر شبکه با یک الگوی ترافیکی پیچیده و متقارن روبرو می‌شود که در آن تشخیص پیام‌های واقعی از نویز تقریباً غیرممکن است. این رویکرد به طور قابل توجهی حریم خصوصی کاربر را در برابر تحلیل ترافیک افزایش می‌دهد.

## ۳. حالت مخفی (Secret Mode)

برای ایجاد یک لایه انکارپذیری (plausible deniability)، سرور قابلیتی به نام "حالت مخفی" را پیاده‌سازی می‌کند. این حالت به کاربر اجازه می‌دهد تا مجموعه‌ای از گفتگوها را پنهان کند، به طوری که این گفتگوها تنها با یک رمز عبور ثانویه قابل دسترسی باشند.

- **مولفه‌های کلیدی:**
  - **رمز عبور ثانویه:** هر کاربر می‌تواند یک "رمز عبور ثانویه" برای حساب خود تعریف کند. این رمز با رمز اصلی ورود متفاوت است و به صورت جداگانه هش شده و ذخیره می‌شود.
  - **گفتگوهای پنهان:** کاربر می‌تواند هر یک از گفتگوهای خود را به عنوان "پنهان" علامت‌گذاری کند.

- **نحوه کار:**
  1. **ورود عادی:** هنگامی که کاربر با رمز عبور اصلی خود وارد سیستم می‌شود (`POST /api/auth/login`)، توکن JWT صادر شده به او اجازه دسترسی به گفتگوهای **عادی (پنهان نشده)** را می‌دهد. در این حالت، هیچ اثری از گفتگوهای پنهان در پاسخ‌های API (مانند `GET /api/conversations`) وجود ندارد.
  2. **ورود به حالت مخفی:** برای دسترسی به گفتگوهای پنهان، کاربر باید از طریق یک نقطه پایانی جداگانه (`POST /api/auth/secret-login`) با استفاده از نام کاربری و **رمز عبور ثانویه** خود وارد شود.
  3. **توکن حالت مخفی:** در صورت موفقیت‌آمیز بودن ورود با رمز ثانویه، سرور یک توکن JWT ویژه صادر می‌کند که حاوی یک ادعای (`claim`) اضافی است: `"secretMode": true`.
  4. **دسترسی به داده‌های مخفی:** هنگامی که کاربر از این توکن ویژه برای ارسال درخواست به سرور استفاده می‌کند (مثلاً `GET /api/conversations`)، سرور این ادعا را تشخیص داده و **فقط و فقط گفتگوهایی را که به عنوان "پنهان" علامت‌گذاری شده‌اند**، برمی‌گرداند.

- **نتیجه:** این مکانیزم یک جداسازی قوی بین دو مجموعه از داده‌ها ایجاد می‌کند. اگر کاربری مجبور شود دسترسی به حساب خود را فراهم کند، می‌تواند با استفاده از رمز عبور اصلی وارد شود و مجموعه‌ای از گفتگوهای غیر حساس را نمایش دهد، در حالی که وجود گفتگوهای پنهان کاملاً مخفی باقی می‌ماند.
