# تحلیل و گزارش جامع امنیتی پروژه

## امتیاز امنیتی کل: 25/100

این امتیاز پایین به دلیل وجود چندین آسیب‌پذیری در سطح **بحرانی (Critical)** است که امنیت هسته اصلی پروژه را به شدت تضعیف می‌کنند. مواردی مانند هاردکد بودن کلیدهای رمزنگاری، ضعف شدید در احراز هویت WebSocket و نقض پروتکل‌های حریم خصوصی طراحی‌شده، به مهاجم اجازه می‌دهد تا به سادگی کنترل سیستم را به دست گرفته، هویت کاربران را جعل کرده و به داده‌های حساس دسترسی پیدا کند. اگرچه پروژه مفاهیم امنیتی پیشرفته‌ای را هدف قرار داده است، اما پیاده‌سازی فعلی آن ناامن و غیرقابل اعتماد است.

---

## تحلیل آسیب‌پذیری‌ها و مشکلات امنیتی

در ادامه، لیستی از آسیب‌پذیری‌های شناسایی‌شده بر اساس سطح بحرانی بودن آن‌ها ارائه می‌شود:

### ۱. هاردکد بودن کلید خصوصی سرور و کلید JWT (سطح: بحرانی)
- **مشکل:** کلید خصوصی RSA سرور (`SERVER_PRIVATE_KEY`) و کلید مورد استفاده برای امضای توکن‌های JWT (`JWT_SECRET`) به صورت متن ساده و با مقادیر پیش‌فرض و ناامن در فایل `.env` قرار گرفته‌اند.
- **نحوه سوءاستفاده:** مهاجمی که به کد منبع یا حتی به متغیرهای محیطی سرور دسترسی پیدا کند، می‌تواند:
    - با استفاده از `JWT_SECRET`، توکن‌های JWT دلخواه برای هر کاربری صادر کرده و به حساب آن‌ها دسترسی کامل پیدا کند.
    - با استفاده از `SERVER_PRIVATE_KEY`، پیام‌های رمزنگاری‌شده در لایه mixnet را رمزگشایی کند.

### ۲. عدم احراز هویت در اتصالات WebSocket (سطح: بحرانی)
- **مشکل:** سرور WebSocket هیچ‌گونه مکانیزم احراز هویتی برای کلاینت‌های متصل‌شونده ندارد. رویداد `go_online` به سادگی یک `userId` را از کلاینت می‌پذیرد و آن را به عنوان شناسه کاربر برای آن اتصال در نظر می‌گیرد.
- **نحوه سوءاستفاده:** یک مهاجم می‌تواند یک اتصال WebSocket برقرار کرده و با ارسال `go_online` با `userId` هر کاربر دیگری، خود را به عنوان آن کاربر جا بزند. این به او اجازه می‌دهد پیام‌ها را از طرف آن کاربر دریافت یا ارسال کند.

### ۳. نقض پروتکل "فرستنده پنهان" در WebSocket (سطح: بحرانی)
- **مشکل:** پروتکل `PROTOCOL.md` به درستی بیان می‌کند که برای حفظ حریم خصوصی، `senderId` نباید به سرور ارسال شود. اما رویداد `send_message` در `server.js` دقیقاً همین `senderId` را از کلاینت دریافت می‌کند.
- **نحوه سوءاستفاده:** این نقص طراحی، هدف اصلی پروتکل "فرستنده پنهان" را کاملاً از بین می‌برد. با شنود ترافیک WebSocket یا دسترسی به لاگ‌های سرور، می‌توان به راحتی مشخص کرد چه کسی کدام پیام را ارسال کرده است.

### ۴. عدم وجود کنترل دسترسی (Authorization) در WebSocket (سطح: بالا)
- **مشکل:** رویدادهای حساس مانند `send_message`، `edit_message` و `delete_message` در WebSocket بررسی نمی‌کنند که آیا کاربری که این درخواست را ارسال کرده (`socket.userId` که خود غیرقابل اعتماد است)، واقعاً عضو آن مکالمه هست یا خیر.
- **نحوه سوءاستفاده:** مهاجم پس از جعل هویت یک کاربر (طبق آسیب‌پذیری شماره ۲)، می‌تواند با دانستن `conversationId` یا `messageId`، در هر مکالمه‌ای پیام ارسال، ویرایش یا حذف کند، حتی اگر عضو آن نباشد.

### ۵. استفاده از رمزنگاری نامعتبر (Non-Authenticated Encryption) (سطح: بالا)
- **مشکل:** توابع رمزنگاری متقارن از حالت `AES-256-CBC` استفاده می‌کنند، اما هیچ کد احراز هویت پیام (MAC) برای تضمین یکپارچگی و اصالت متن رمز شده پیاده‌سازی نشده است.
- **نحوه سوءاستفاده:** این ضعف، متن رمز شده را در برابر حملات "malleability" مانند Padding Oracle آسیب‌پذیر می‌کند. مهاجم می‌تواند بدون دانستن کلید، متن رمز شده را دستکاری کرده و بر روی متن اصلی رمزگشایی‌شده تأثیر بگذارد.

### ۶. شمارش نام کاربری (Username Enumeration) از طریق صفحه ورود (سطح: متوسط)
- **مشکل:** در بخش ورود (`/api/auth/login`)، پاسخ سرور برای نام کاربری ناموجود با پاسخ برای رمز عبور اشتباه یکسان نیست و این به مهاجم اجازه می‌دهد تا وجود یا عدم وجود کاربر را تشخیص دهد.
- **نحوه سوءاستفاده:** مهاجم می‌تواند با ارسال لیستی از نام‌های کاربری یا ایمیل‌ها و تحلیل پاسخ‌های سرور، تشخیص دهد که کدامیک از آن‌ها در سیستم ثبت‌نام کرده‌اند.

---

## راه‌حل‌ها و نحوه برطرف کردن مشکلات

### ۱. مدیریت امن کلیدها
- کلیدهای `JWT_SECRET` و `SERVER_PRIVATE_KEY` باید فوراً از فایل `.env` حذف شوند. این مقادیر هرگز نباید در مخزن کد (Git) قرار گیرند.
- **راه‌حل:**
    - یک فایل `.env.example` ایجاد کنید که فقط نام متغیرها را مشخص کند:
      ```
      JWT_SECRET=
      MONGO_URI=mongodb://localhost/messenger
      SERVER_PRIVATE_KEY=
      ```
    - در محیط پروداکشن، این مقادیر باید از طریق مکانیزم‌های امن مدیریت متغیرهای محیطی (مانند Docker Secrets, Vault, یا متغیرهای محیطی سیستم‌عامل) به برنامه تزریق شوند.
    - برای `JWT_SECRET` یک مقدار طولانی و تصادفی با استفاده از `openssl rand -hex 32` تولید کنید.

### ۲. پیاده‌سازی احراز هویت در WebSocket
- قبل از پذیرش هرگونه رویدادی از کلاینت، هویت او باید از طریق توکن JWT تأیید شود.
- **راه‌حل:**
    - از یک میان‌افزار (middleware) برای سوکت `socket.io` استفاده کنید. این میان‌افزار باید در زمان اتصال، توکن JWT را از کلاینت دریافت کرده (مثلاً از طریق `socket.handshake.auth`)، آن را با `JWT_SECRET` اعتبارسنجی کند و در صورت موفقیت، `userId` را به آبجکت `socket` متصل کند.
    - رویداد `go_online` باید حذف شده و وضعیت آنلاین بودن کاربر مستقیماً پس از احراز هویت موفق در `socket` ثبت شود.

### ۳. اصلاح پیاده‌سازی WebSocket
- **برای "فرستنده پنهان":** رویداد `send_message` در `server.js` باید اصلاح شود تا دیگر `senderId` را از کلاینت دریافت نکند. `senderId` باید از توکن JWT احرازهویت‌شده در `socket` خوانده شود.
- **برای کنترل دسترسی:** در تمام رویدادهای حساس (`send_message`, `edit_message`, `delete_message`)، ابتدا از پایگاه داده بررسی کنید که آیا `socket.userId` عضوی از `conversationId` مورد نظر است یا خیر.

### ۴. استفاده از رمزنگاری تصدیق‌شده (Authenticated Encryption)
- حالت رمزنگاری `AES-256-CBC` باید با `AES-256-GCM` جایگزین شود. GCM علاوه بر رمزنگاری، یک تگ احراز هویت (Authentication Tag) نیز تولید می‌کند که یکپارچگی و اصالت داده را تضمین می‌کند.
- **راه‌حل:**
    - توابع `encryptSymmetric` و `decryptSymmetric` را در `src/utils/crypto.js` بازنویسی کنید تا از `crypto.createCipheriv('aes-256-gcm', ...)` و `crypto.createDecipheriv('aes-256-gcm', ...)` استفاده کنند. تگ احراز هویت باید همراه با متن رمز شده ذخیره و در زمان رمزگشایی تأیید شود.

### ۵. جلوگیری از شمارش نام کاربری
- پاسخ‌های بخش ورود باید برای تمام خطاهای مربوط به احراز هویت یکسان باشند.
- **راه‌حل:**
    - در کنترلر `login`، در صورتی که `user` پیدا نشود یا `isMatch` (تطابق رمز عبور) `false` باشد، همیشه یک پاسخ یکسان مانند `res.status(401).send({ error: 'Invalid credentials' })` برگردانید.

---

## توصیه‌های کلیدی برای بهبود امنیت

1.  **اجرای اسکن امنیتی خودکار (SAST/DAST):** ابزارهایی مانند `npm audit`, Snyk, یا GitHub Dependabot را در چرخه CI/CD خود ادغام کنید تا وابستگی‌های آسیب‌پذیر را به صورت خودکار شناسایی و مدیریت کنید.
2.  **افزودن هدرهای امنیتی HTTP:** از میان‌افزارهایی مانند `helmet` در Express استفاده کنید تا هدرهای امنیتی استاندارد (مانند `Strict-Transport-Security`, `X-Content-Type-Options`, `Content-Security-Policy`) به تمام پاسخ‌های HTTP اضافه شوند. این کار از حملات رایج تحت وب مانند XSS و Clickjacking جلوگیری می‌کند.
3.  **شبکه‌بندی امن در Docker:** در `docker-compose.yml`، یک شبکه سفارشی (custom bridge network) برای سرویس‌ها تعریف کنید و فقط پورت‌هایی را که نیاز به دسترسی از خارج دارند (مانند پورت وب‌سرور) `expose` کنید. ارتباط بین کانتینرها (مانند اپلیکیشن و دیتابیس) باید از طریق این شبکه داخلی انجام شود و پورت دیتابیس نباید روی هاست میزبان باز باشد.
4.  **لاگ‌برداری امن و جامع:** تمام رویدادهای امنیتی مهم (ورود موفق، ورود ناموفق، تغییر رمز عبور، خطاهای سرور) را به صورت متمرکز و امن لاگ‌برداری کنید. هرگز اطلاعات حساس مانند رمز عبور یا توکن را در لاگ‌ها ذخیره نکنید.
5.  **بازبینی دوره‌ای کد (Code Review):** تمام تغییرات کد، به ویژه بخش‌های مرتبط با امنیت، باید قبل از ادغام در شاخه اصلی توسط یک توسعه‌دهنده دیگر بازبینی شوند. این فرآیند به شناسایی زودهنگام خطاها کمک شایانی می‌کند.
