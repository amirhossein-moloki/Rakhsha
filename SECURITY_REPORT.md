# تحلیل و گزارش جامع امنیتی پروژه رخشان

## امتیاز امنیتی کل: 45/100

این پروژه تلاش‌های قابل توجهی در زمینه پیاده‌سازی مفاهیم امنیتی پیشرفته مانند پروتکل Signal (برای کلیدها)، پنهان‌سازی ترافیک و حالت انکارپذیری (Plausible Deniability) انجام داده است. معماری کلی، به ویژه در بخش WebSocket و مقابله با حملات شمارش نام کاربری، نشان از درک عمیق مسائل امنیتی دارد. با این حال، وجود یک **آسیب‌پذیری بحرانی در پیاده‌سازی رمزنگاری** و چند ضعف امنیتی مهم دیگر، عملاً بسیاری از این تدابیر را بی‌اثر کرده و امنیت هسته اصلی برنامه را به شدت به خطر انداخته است. امتیاز فعلی این نواقص حیاتی را منعکس می‌کند.

---

## تحلیل آسیب‌پذیری‌ها و مشکلات امنیتی

در ادامه، لیستی از آسیب‌پذیری‌های شناسایی‌شده بر اساس تحلیل کدبیس فعلی ارائه می‌شود:

### ۱. پیاده‌سازی ناقص و نادرست پروتکل تبادل کلید ECDH (سطح: بحرانی)
- **مشکل:** تابع `computeECDHSharedSecret` در فایل `src/utils/crypto.js` کلید خصوصی را با انکدینگ `base64` دریافت می‌کند، در حالی که تابع `generateECDHKeyPair` کلیدها را با انکدینگ `hex` تولید می‌کند. این عدم تطابق باعث تولید یک کلید مشترک (Shared Secret) کاملاً اشتباه یا بروز خطا در حین اجرا می‌شود.
- **نحوه سوءاستفاده:** این آسیب‌پذیری، کل فرآیند تبادل کلید برای رمزنگاری سرتاسری (E2EE) را بی‌اثر می‌کند. پیام‌ها یا با کلیدهای اشتباه رمزگذاری می‌شوند که به سادگی قابل شکستن هستند، یا فرآیند رمزگشایی در سمت گیرنده با شکست مواجه می‌شود. در عمل، هیچ ارتباط امنی بین کاربران برقرار نمی‌شود و حریم خصوصی پیام‌ها به طور کامل از بین می‌رود.

### ۲. مدیریت ناامن کلیدهای اصلی سرور (سطح: بحرانی)
- **مشکل:** فایل `docker-compose.yml` نشان می‌دهد که متغیرهای حساس `JWT_SECRET` و `SERVER_PRIVATE_KEY` از طریق متغیرهای محیطی به کانتینر تزریق می‌شوند. اگر این مقادیر در یک فایل `.env` که در مخزن کد (Git) قرار گرفته باشد، ذخیره شوند، این یک نقص امنیتی فاجعه‌بار است. (این مورد در گزارش نمونه کاربر ذکر شده بود و یک ریسک رایج و حیاتی است).
- **نحوه سوءاستفاده:** هر فردی که به کد منبع دسترسی داشته باشد، می‌تواند با استفاده از `JWT_SECRET` توکن جعلی برای هر کاربری بسازد و هویت او را سرقت کند و با `SERVER_PRIVATE_KEY` می‌تواند در ارتباطات مبتنی بر Mixnet دخالت کند.

### ۳. عدم وجود محدودیت نرخ درخواست (Rate Limiting) در مسیرهای احراز هویت (سطح: بالا)
- **مشکل:** مسیرهای `POST /api/auth/login` و `POST /api/auth/register` فاقد هرگونه مکانیزم محدودیت نرخ درخواست هستند. اگرچه پروژه در برابر حملات زمان‌بندی (Timing Attack) در صفحه ورود مقاوم است، اما در برابر حملات Brute-force آسیب‌پذیر است.
- **نحوه سوءاستفاده:** یک مهاجم می‌تواند با ارسال تعداد زیادی درخواست به مسیر `login`، اقدام به حدس زدن رمز عبور کاربران معتبر کند. همچنین می‌تواند با ارسال درخواست‌های ثبت‌نام متعدد، باعث ایجاد بار اضافی روی سرور و پایگاه داده شود (Resource Exhaustion).

### ۴. ذخیره‌سازی ناامن فایل‌ها (سطح: متوسط)
- **مشکل:** فایل‌های آپلود شده در پوشه `uploads` روی فایل سیستم محلی کانتینر ذخیره می‌شوند. این پیاده‌سازی چند مشکل دارد:
    1.  **عدم ماندگاری داده‌ها:** در فایل `docker-compose.yml` هیچ Volume پایداری برای این پوشه تعریف نشده است. با ری‌استارت شدن کانتینر، تمام فایل‌ها از بین می‌روند.
    2.  **عدم مقیاس‌پذیری:** این روش در محیط‌های چندکانتینری قابل استفاده نیست.
    3.  **ریسک Path Traversal:** استفاده از `path.extname(req.file.originalname)` برای تعیین پسوند فایل، اگرچه در کنار `path.join` نسبتاً امن است، اما بهترین رویه نیست و بهتر است پسوند فایل از روی نوع MIME معتبر آن استخراج شود.
- **نحوه سوءاستفاده:** مشکل اصلی در اینجا قابلیت اطمینان و در دسترس بودن (Reliability/Availability) است، اما استفاده از ورودی کاربر در مسیر فایل همیشه یک ریسک امنیتی بالقوه محسوب می‌شود.

---

## راه‌حل‌ها و نحوه برطرف کردن مشکلات

### ۱. اصلاح تابع تبادل کلید ECDH
- انکدینگ کلیدها در تابع `computeECDHSharedSecret` باید با فرمت تولید شده در `generateECDHKeyPair` (یعنی `hex`) یکسان شود.
- **راه‌حل در `src/utils/crypto.js`:**
  ```javascript
  const computeECDHSharedSecret = (privateKey, otherPublicKey) => {
      const ecdh = crypto.createECDH('secp256k1');
      // FIX: Load the private key in 'hex' format
      ecdh.setPrivateKey(privateKey, 'hex');
      // FIX: Compute the secret using the public key also in 'hex' format
      return ecdh.computeSecret(otherPublicKey, 'hex', 'hex');
  };
  ```

### ۲. مدیریت امن کلیدها
- کلیدها هرگز نباید در مخزن کد قرار گیرند.
- **راه‌حل:**
    - یک فایل `.env.example` در پروژه قرار دهید تا ساختار متغیرها را مشخص کند.
    - فایل `.env` را به `.gitignore` اضافه کنید.
    - در محیط پروداکشن، از سیستم‌های مدیریت اسرار مانند Docker Secrets، HashiCorp Vault یا متغیرهای محیطی امن پلتفرم ابری استفاده کنید.
    - مقادیر پیش‌فرض قوی و تصادفی برای کلیدها تولید کنید.

### ۳. پیاده‌سازی Rate Limiting
- از پکیج `express-rate-limit` که از قبل در `package.json` موجود است، برای محافظت از مسیرهای حساس استفاده کنید.
- **راه‌حل در `src/app.js`:**
  ```javascript
  const rateLimit = require('express-rate-limit');
  const authRoutes = require('./routes/auth');

  const authLimiter = rateLimit({
      windowMs: 15 * 60 * 1000, // 15 minutes
      max: 100, // Limit each IP to 100 requests per windowMs
      standardHeaders: true,
      legacyHeaders: false,
  });

  // Apply the rate limiter to authentication routes
  app.use('/api/auth', authLimiter, authRoutes);
  ```

### ۴. استفاده از ذخیره‌سازی پایدار و امن برای فایل‌ها
- برای ذخیره‌سازی فایل‌ها باید از یک Volume پایدار در داکر یا ترجیحاً یک سرویس Object Storage خارجی استفاده شود.
- **راه‌حل (ساده با Docker Volume):**
  - در `docker-compose.yml`:
    ```yaml
    services:
      app:
        # ...
        volumes:
          - uploads-data:/app/uploads # Map a volume to the uploads directory

    volumes:
      mongo-data:
      uploads-data: # Define the volume
    ```
- **راه‌حل (پیشرفته):** برنامه را برای استفاده از سرویس‌هایی مانند AWS S3 یا MinIO بازنویسی کنید.

---

## توصیه‌های کلیدی برای بهبود امنیت

1.  **تقدیر از نقاط قوت:** این پروژه دارای نقاط قوت امنیتی بسیاری است: پیاده‌سازی صحیح WebSocket با احراز هویت و کنترل دسترسی، استفاده از `AES-256-GCM`، حفاظت در برابر شمارش نام کاربری و طراحی دقیق پروتکل‌های حریم خصوصی. این تلاش‌ها باید حفظ و تقویت شوند.
2.  **اجرای تست‌های امنیتی:** تست‌های واحد (Unit Tests) برای توابع رمزنگاری بنویسید تا از صحت عملکرد آن‌ها (مانند مورد ECDH) اطمینان حاصل شود. این تست‌ها باید موارد مرزی و خطاهای مورد انتظار را پوشش دهند.
3.  **پیکربندی Content-Security-Policy (CSP):** از طریق هدرهای `helmet`، یک سیاست CSP قوی و محدودکننده تعریف کنید تا ریسک حملات Cross-Site Scripting (XSS) به حداقل برسد.
4.  **لاگ‌برداری متمرکز و امن:** رویدادهای امنیتی (ورود موفق و ناموفق، خطاهای مهم) را به صورت ساختاریافته لاگ کرده و به یک سیستم متمرکز ارسال کنید. از ثبت اطلاعات حساس در لاگ‌ها خودداری کنید.
5.  **اصل حداقل دسترسی (Principle of Least Privilege):** اطمینان حاصل کنید که پروسه Node.js در داخل کانتینر با یک کاربر غیر-root اجرا می‌شود. این کار را می‌توان با افزودن دستورات `USER` در `Dockerfile` انجام داد.
